name: 'Build Android APK'
description: '构建并签名 Android APK'
inputs:
  app-version:
    description: '应用版本号'
    required: true
  signing-key:
    description: 'Base64 编码的签名密钥'
    required: true
  keystore-password:
    description: 'Keystore 密码'
    required: true
  key-alias:
    description: '密钥别名'
    required: true
  key-password:
    description: '密钥密码'
    required: true
outputs:
  apk-path:
    description: '生成的 APK 文件路径'
    value: ${{ steps.build.outputs.apk_path }}
runs:
  using: 'composite'
  steps:
    - name: Setup Android SDK
      uses: android-actions/setup-android@v3

    - name: Accept Android SDK licenses
      shell: bash
      run: |
        set +o pipefail
        yes | sdkmanager --licenses >/dev/null
        set -o pipefail

    - name: Install 7zip dependency
      shell: bash
      run: |
        sudo apt-get update
        sudo apt-get install -y --no-install-recommends p7zip-full

    - name: Prefetch MDK SDK for fvp
      shell: bash
      run: |
        set -euo pipefail
        if [ ! -f "pubspec.lock" ]; then
          echo "pubspec.lock 不存在，无法解析 fvp 版本。"
          exit 1
        fi
        FVP_VERSION=$(awk '
          /^  fvp:/ {flag=1; next}
          flag {
            if ($0 ~ /^    version:/) {
              gsub(/"/, "", $2);
              print $2;
              exit
            }
            if ($0 !~ /^    /) {
              exit
            }
          }
        ' pubspec.lock)
        if [ -z "$FVP_VERSION" ]; then
          echo "未能在 pubspec.lock 中找到 fvp 依赖的版本号。"
          exit 1
        fi
        CACHE_BASE="$HOME/.pub-cache/hosted/pub.dev"
        FVP_DIR="$CACHE_BASE/fvp-$FVP_VERSION"
        ANDROID_DIR="$FVP_DIR/android"
        MDK_MARKER="$ANDROID_DIR/mdk-sdk/lib/cmake/FindMDK.cmake"
        if [ -f "$MDK_MARKER" ]; then
          echo "已存在 MDK 依赖，跳过下载。"
          exit 0
        fi
        mkdir -p "$ANDROID_DIR"
        ARCHIVE="$ANDROID_DIR/mdk-sdk-android.7z"
        MDK_URL="${FVP_DEPS_URL:-https://github.com/wang-bin/mdk-sdk/releases/latest/download/}/mdk-sdk-android.7z"
        echo "Downloading mdk-sdk from $MDK_URL"
        curl -L --fail --retry 5 --retry-all-errors -o "$ARCHIVE" "$MDK_URL"
        7z x "$ARCHIVE" -o"$ANDROID_DIR" >/dev/null
        rm -f "$ARCHIVE"
        if [ ! -f "$MDK_MARKER" ]; then
          echo "mdk-sdk 解压失败"
          exit 1
        fi

    - name: Configure Gradle
      shell: bash
      run: |
        mkdir -p ~/.gradle
        cat > ~/.gradle/gradle.properties << EOF
        org.gradle.jvmargs=-Xmx4096m -XX:MaxMetaspaceSize=1024m -XX:+HeapDumpOnOutOfMemoryError
        org.gradle.parallel=true
        org.gradle.caching=true
        org.gradle.daemon=true
        systemProp.http.connectionTimeout=60000
        systemProp.http.socketTimeout=60000
        systemProp.https.connectionTimeout=60000
        systemProp.https.socketTimeout=60000
        EOF

    - name: Install Android build tools
      shell: bash
      run: |
        set -euo pipefail

        SDK_ROOT="${ANDROID_SDK_ROOT:-${ANDROID_HOME:-}}"
        if [ -z "${SDK_ROOT}" ]; then
          echo "错误：ANDROID_SDK_ROOT/ANDROID_HOME 未设置，无法安装 NDK。"
          exit 1
        fi

        # 从项目配置读取 ndkVersion，避免 CI 与项目不一致导致找不到 clang
        NDK_VERSION="$(grep -E '^[[:space:]]*ndkVersion[[:space:]]*=' -m 1 android/app/build.gradle | sed -E 's/.*['\''"]([^'\''"]+)['\''"].*/\1/')"
        if [ -z "${NDK_VERSION}" ]; then
          echo "错误：未能从 android/app/build.gradle 解析 ndkVersion。"
          exit 1
        fi

        echo "Installing Android SDK packages:"
        echo "- build-tools;29.0.3"
        echo "- ndk;${NDK_VERSION}"
        echo "- cmake;3.22.1"

        # sdkmanager 在 pipefail 下可能因为 yes 的 SIGPIPE 导致误判失败，这里临时关闭 pipefail
        set +o pipefail
        yes 2>/dev/null | sdkmanager --sdk_root="${SDK_ROOT}" "build-tools;29.0.3" "ndk;${NDK_VERSION}" "cmake;3.22.1"
        set -o pipefail

        NDK_DIR="${SDK_ROOT}/ndk/${NDK_VERSION}"
        if [ ! -d "${NDK_DIR}" ]; then
          echo "错误：NDK 目录不存在：${NDK_DIR}"
          echo "当前 ${SDK_ROOT}/ndk 目录："
          ls -la "${SDK_ROOT}/ndk" || true
          exit 1
        fi

        CLANG_PATH=""
        for prebuilt_dir in "${NDK_DIR}/toolchains/llvm/prebuilt"/*; do
          if [ -e "${prebuilt_dir}/bin/clang" ]; then
            CLANG_PATH="${prebuilt_dir}/bin/clang"
            break
          fi
        done
        if [ -z "${CLANG_PATH}" ]; then
          echo "错误：Android NDK clang 未找到（Flutter 需要它）：${NDK_DIR}"
          echo "toolchains/llvm/prebuilt 目录："
          ls -la "${NDK_DIR}/toolchains/llvm/prebuilt" || true
          for prebuilt_dir in "${NDK_DIR}/toolchains/llvm/prebuilt"/*; do
            echo "=== ${prebuilt_dir}/bin ==="
            ls -la "${prebuilt_dir}/bin" || true
          done
          exit 1
        fi
        echo "NDK clang: ${CLANG_PATH}"

        {
          echo "ANDROID_SDK_ROOT=${SDK_ROOT}"
          echo "ANDROID_HOME=${SDK_ROOT}"
          echo "ANDROID_NDK_HOME=${NDK_DIR}"
          echo "ANDROID_NDK_ROOT=${NDK_DIR}"
          echo "NDK_HOME=${NDK_DIR}"
        } >> "$GITHUB_ENV"
    
    - name: Build and Sign Android
      id: build
      shell: bash
      run: |
        # 构建分架构APK
        echo "=== 构建Android APK (32位 + 64位) ==="
        # 构建32位和64位ARM架构的分离APK
        flutter build apk --release --split-per-abi

        # 构建通用APK (包含所有架构)
        echo "=== 构建通用APK (包含所有架构) ==="
        flutter build apk --release

        # 检查生成的APK文件
        echo "检查构建输出目录："
        ls -la build/app/outputs/flutter-apk/

        # 创建签名配置文件
        echo "${{ inputs.signing-key }}" | base64 -d > keystore.jks

        # 确保输出目录存在
        mkdir -p "build/app/outputs/apk/release"

        # 检查实际生成的APK文件并动态处理
        echo "=== 检测生成的APK文件 ==="
        declare -A arch_apks=()

        # 检查通用APK（如果配置了单一架构或未分架构）
        if [ -f "build/app/outputs/flutter-apk/app-release.apk" ]; then
          echo "发现通用APK: app-release.apk"
          arch_apks["universal"]="build/app/outputs/flutter-apk/app-release.apk"
        fi

        # 检查分架构APK
        if [ -f "build/app/outputs/flutter-apk/app-armeabi-v7a-release.apk" ]; then
          echo "发现ARMv7 APK: app-armeabi-v7a-release.apk"
          arch_apks["armeabi-v7a"]="build/app/outputs/flutter-apk/app-armeabi-v7a-release.apk"
        fi

        if [ -f "build/app/outputs/flutter-apk/app-arm64-v8a-release.apk" ]; then
          echo "发现ARM64 APK: app-arm64-v8a-release.apk"
          arch_apks["arm64-v8a"]="build/app/outputs/flutter-apk/app-arm64-v8a-release.apk"
        fi

        if [ -f "build/app/outputs/flutter-apk/app-x86-release.apk" ]; then
          echo "发现x86 APK: app-x86-release.apk"
          arch_apks["x86"]="build/app/outputs/flutter-apk/app-x86-release.apk"
        fi

        if [ -f "build/app/outputs/flutter-apk/app-x86_64-release.apk" ]; then
          echo "发现x86_64 APK: app-x86_64-release.apk"
          arch_apks["x86_64"]="build/app/outputs/flutter-apk/app-x86_64-release.apk"
        fi

        # 检查是否找到了APK文件
        if [ ${#arch_apks[@]} -eq 0 ]; then
          echo "错误：未找到任何APK文件"
          exit 1
        fi

        # 处理每个架构的APK
        signed_apks=()
        for arch in "${!arch_apks[@]}"; do
          input_apk="${arch_apks[$arch]}"

          # 根据架构类型设置输出文件名
          if [ "$arch" = "universal" ]; then
            output_apk="build/app/outputs/apk/release/NipaPlay-${{ inputs.app-version }}-Android-universal.apk"
          else
            output_apk="build/app/outputs/apk/release/NipaPlay-${{ inputs.app-version }}-Android-${arch}.apk"
          fi

          echo "=== 处理 ${arch} 架构 ==="
          echo "输入APK: $input_apk"
          echo "输出APK: $output_apk"

          # 检查APK文件是否存在
          if [ ! -f "$input_apk" ]; then
            echo "错误：${arch} APK文件不存在: $input_apk"
            exit 1
          fi

          # 检查APK文件是否有效
          if ! unzip -t "$input_apk" >/dev/null 2>&1; then
            echo "错误：${arch} APK文件损坏或无效: $input_apk"
            continue
          fi

          # 使用zipalign对APK进行对齐
          temp_aligned="temp-aligned-${arch}.apk"
          $ANDROID_HOME/build-tools/29.0.3/zipalign -v -p 4 \
            "$input_apk" \
            "$temp_aligned"

          # 使用apksigner对APK进行签名
          $ANDROID_HOME/build-tools/29.0.3/apksigner sign \
            --ks keystore.jks \
            --ks-pass pass:${{ inputs.keystore-password }} \
            --ks-key-alias ${{ inputs.key-alias }} \
            --key-pass pass:${{ inputs.key-password }} \
            --out "$output_apk" \
            "$temp_aligned"

          # 删除临时文件
          rm -f "$temp_aligned"

          # 删除未签名的APK
          rm -f "$input_apk"

          # 添加到已签名APK列表
          signed_apks+=("$output_apk")
          echo "✅ ${arch} APK签名完成: $output_apk"
        done

        # 删除keystore
        rm -f keystore.jks

        # 验证最终的APK文件
        echo "=== 最终APK文件列表 ==="
        ls -lh build/app/outputs/apk/release/NipaPlay*.apk

        # 检查是否有成功生成的APK
        if [ ${#signed_apks[@]} -eq 0 ]; then
          echo "错误：没有成功生成任何APK文件"
          exit 1
        fi

        # 输出APK路径（多个APK用分号分隔）
        apk_paths=$(IFS=';'; echo "${signed_apks[*]}")
        echo "apk_path=$apk_paths" >> $GITHUB_OUTPUT
        echo "生成的APK数量: ${#signed_apks[@]}"
